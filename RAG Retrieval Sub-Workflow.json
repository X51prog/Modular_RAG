{
  "name": "Retrieval Sub-Workflow",
  "nodes": [
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With Dynamic Hybrid Search & Context Expansion)",
        "height": 648,
        "width": 1052,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        14560,
        7504
      ],
      "id": "58048e90-ec46-47b1-86ef-c4e6096653c0",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "",
        "height": 648,
        "width": 840,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13696,
        7504
      ],
      "id": "8cbb3fa7-84ed-4f19-a01c-a21293cf4d2d",
      "name": "Sticky Note18"
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        14960,
        7952
      ],
      "id": "e3ccf5cd-a982-4e6c-935a-da851d3e43d9",
      "name": "Supabase Short-Term Memory",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "## v2.3.3\nThis it the agentic inference workflow for both our SOTA RAG System and RAG At Scale System\n\nSOTA RAG Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/state-of-the-art-n8n-rag-agent\n\nRAG at Scale Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/rag-at-scale-system",
        "height": 244,
        "width": 580,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13856,
        7872
      ],
      "id": "7de3f727-2f78-4d9e-a833-45371af729d5",
      "name": "Sticky Note21"
    },
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With Long Term Memory)",
        "height": 648,
        "width": 2076,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17136,
        7504
      ],
      "id": "03c619c2-a694-4929-9a7e-30a582d3dc05",
      "name": "Sticky Note20",
      "disabled": true
    },
    {
      "parameters": {
        "name": "Query_Knowledge_Graph",
        "description": "Call this to query data from our knowledge graph",
        "workflowId": {
          "__rl": true,
          "value": "A4BVrX5qYlJ7HUMI",
          "mode": "list",
          "cachedResultName": "TheAIAutomators.com - RAG Masterclass - Lesson 9 - SOTA - v2.0 Dev 0.3"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "type": "graph"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.1,
      "position": [
        18336,
        7984
      ],
      "id": "4ec94b8b-e091-4f73-b003-345e62a6a768",
      "name": "Query Knowledge Graph1",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "disabled": true
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        17680,
        7984
      ],
      "id": "77b9d649-506f-45f7-9745-ef0adabd7c25",
      "name": "Supabase Short-Term Memory2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.getzep.com/api/v2/graph/search",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"user_id\": \"{{ $json.user_id }}\",\n  \"query\": {{ JSON.stringify($('When chat message received').item.json.chatInput) }},\n  \"scope\": \"edges\",\n  \"limit\": 5,\n  \"search_filters\": {\n    \"min_relevance\": 0.7\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        17568,
        7728
      ],
      "id": "67db25dc-87e3-48ac-a4b5-1eead9c64bd9",
      "name": "Get Long Term Memories",
      "disabled": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        18480,
        7792
      ],
      "id": "4ee08aaf-604c-4f8a-8660-4b87fea3094e",
      "name": "Respond to Webhook",
      "disabled": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "c2e95998-ad5f-4676-b307-b91f5c4adaad",
              "name": "user_id",
              "value": "user1234",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        17312,
        7728
      ],
      "id": "0131c2ee-2778-4c34-86ac-09c11d4667f9",
      "name": "user_id",
      "disabled": true
    },
    {
      "parameters": {
        "content": "Note: This template uses n8n chat and by default, this long term memory is shared across all chat sessions. To maintain separate long term memories for different users, check out our community post here, as there are multiple approaches for this depending on how you're deploying the agent. ",
        "height": 192,
        "width": 256,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        17232,
        7904
      ],
      "typeVersion": 1,
      "id": "cf2cf6a5-bab3-46a6-afb4-c26a5a4168f0",
      "name": "Sticky Note25",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## TODO\n### Add User ID here",
        "height": 232,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17248,
        7648
      ],
      "id": "a29557cd-fe5b-451d-b1a7-b74c77bdb2fe",
      "name": "Sticky Note26",
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Execute a SQL query on the tabular_document_rows table.\n\nInstructions:\n\nYou will always be querying based on a specific id.\n\nEach row in the table contains a row_data field (of type jsonb) that holds the data for that row, with keys matching the file schema defined in the record_manager table.\n\nThe record_manager_id is the id field from the record_manager table. Always filter based on this specific id when querying the tabular_document_rows table.\n\nWhen writing your SELECT clause, extract values from the row_data JSON using the ->> operator and cast them as needed (e.g., to numeric for calculations).\n\nItems within your SELECT needs to use the data within row_data field.\n\nExample query: Find maximum value for a field (e.g. \"profit\")\n\nSELECT MAX((row_data->>'profit')::numeric) AS max_profit\nFROM tabular_document_rows\nWHERE file_id = '123';\n\nExample query: Group and aggregate (e.g. total revenue by country)\n\nSELECT row_data->>'country' AS country,\n       SUM((row_data->>'revenue')::numeric) AS total_revenue\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'country';\n\nExample query: Group and aggregate (e.g. total revenue by country)\nSELECT row_data->>'salesperson' AS salesperson,\n       SUM((row_data->>'profit')::numeric) AS total_profit\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'salesperson';",
        "operation": "executeQuery",
        "query": "{{ $fromAI('sql_query') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        18000,
        7984
      ],
      "id": "d260c6d1-91ff-4d99-80ed-9fcd2bab0888",
      "name": "Query Tabular Rows1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Use this tool to fetch all available documents from the record_manager, this will include the table schema and the id",
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "record_manager_v2",
          "mode": "list",
          "cachedResultName": "record_manager_v2"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "data_type",
              "value": "tabular"
            }
          ]
        },
        "options": {
          "outputColumns": [
            "id",
            "document_title",
            "schema"
          ]
        }
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        17840,
        7984
      ],
      "id": "dee1518c-681c-458b-89a9-f1e0245a54f9",
      "name": "Get datasets from record_manager1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.getzep.com/api/v2/users",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\"user_id\":\"user1234\"}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        18944,
        7840
      ],
      "id": "4fd847c4-7c83-4eb8-8f4f-4c1b29c3e500",
      "name": "Create Zep User",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## TODO\n### Run this node once to manually create a Zep user",
        "height": 312,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        18880,
        7696
      ],
      "id": "0cb7379b-3cd8-4dd1-97af-c7404ac86345",
      "name": "Sticky Note27",
      "disabled": true
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "jfvPAjwlf1jVaW3Y",
          "mode": "list",
          "cachedResultName": "Zep - Update Long Term Memories - BLUEPRINT"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "session_id": "={{ $('When chat message received').item.json.sessionId }}",
            "user_id": "={{ $('user_id').item.json.user_id }}",
            "message_content": "={{ $('When chat message received').item.json.chatInput }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "user_id",
              "displayName": "user_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "message_content",
              "displayName": "message_content",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        18480,
        7584
      ],
      "id": "28eff85d-8c2f-4a53-be79-95d66d048385",
      "name": "Execute workflow - Save Zep long term memories",
      "disabled": true
    },
    {
      "parameters": {
        "public": true,
        "authentication": "n8nUserAuth",
        "initialMessages": "Hi there! ðŸ‘‹\n",
        "availableInChat": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [
        14048,
        7680
      ],
      "id": "ed1dc4b5-ebe9-466c-a294-26737593a585",
      "name": "When chat message received",
      "webhookId": "5e442826-4547-4647-8d24-1641210f2a8e"
    },
    {
      "parameters": {
        "name": "Query_Knowledge_Graph",
        "description": "Call this to query data from our knowledge graph",
        "workflowId": {
          "__rl": true,
          "value": "suQZAl0QM15VyY3R",
          "mode": "list",
          "cachedResultUrl": "/workflow/suQZAl0QM15VyY3R",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.3 Blueprint"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "type": "graph"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.1,
      "position": [
        16560,
        7952
      ],
      "id": "8ae7de5c-2450-46b2-a8d3-9fe7090e00b7",
      "name": "Query Knowledge Graph2",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "disabled": true
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        15888,
        7952
      ],
      "id": "d86907df-5c28-424a-b13c-dd67f9ef91f1",
      "name": "Supabase Short-Term Memory3",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Execute a SQL query on the tabular_document_rows table. \n\nInstructions:\n\nYou will always be querying based on a specific id.\n\nEach row in the table contains a row_data field (of type jsonb) that holds the data for that row, with keys matching the file schema defined in the record_manager table.\n\nThe record_manager_id is the id field from the record_manager table. Always filter based on this specific id when querying the tabular_document_rows table.\n\nWhen writing your SELECT clause, extract values from the row_data JSON using the ->> operator and cast them as needed (e.g., to numeric for calculations).\n\nWhen applying WHERE clauses, you should run SELECT DISTINCT queries (LIMIT 100) on the relevant fields first to understand the valid options. This applies even if the user provides a specific valueâ€”you must verify that the value exists in the data before using it.\n\nDo NOT run SELECT DISTINCT queries for ID columns.\n\nItems within your SELECT needs to use the data within row_data field.\n\nExample query: Find maximum value for a field (e.g. \"profit\")\n\nSELECT MAX((row_data->>'profit')::numeric) AS max_profit\nFROM tabular_document_rows\nWHERE file_id = '123';\n\nExample query: Group and aggregate (e.g. total revenue by country)\n\nSELECT row_data->>'country' AS country,\n       SUM((row_data->>'revenue')::numeric) AS total_revenue\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'country';\n\nExample query: Group and aggregate (e.g. total revenue by country)\nSELECT row_data->>'salesperson' AS salesperson,\n       SUM((row_data->>'profit')::numeric) AS total_profit\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'salesperson';",
        "operation": "executeQuery",
        "query": "{{ $fromAI('sql_query') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        16208,
        7952
      ],
      "id": "a63d5f8f-80b9-4cf1-b80e-7a42c84a423c",
      "name": "Query Tabular Rows2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Use this tool to fetch all available documents from the record_manager, this will include the table schema and the id",
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "record_manager_v2",
          "mode": "list",
          "cachedResultName": "record_manager_v2"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "data_type",
              "value": "tabular"
            }
          ]
        },
        "options": {
          "outputColumns": [
            "id",
            "document_title",
            "schema"
          ]
        }
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        16048,
        7952
      ],
      "id": "5b17eecf-f72f-4d4c-91d4-4331e7a4c18c",
      "name": "Get datasets from record_manager2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With GraphRAG + NLQ)",
        "height": 648,
        "width": 1468,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        15632,
        7504
      ],
      "id": "acb30a3c-d61d-4a13-abd3-0879ee25b10b",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## TODO\n### Connect the Chat Trigger to your Agent of Choice",
        "height": 256,
        "width": 576
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13856,
        7584
      ],
      "id": "a0b5308f-7433-46c0-bd25-ffe1bd8d63ec",
      "name": "Sticky Note29"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        15728,
        7952
      ],
      "id": "02a71b6d-5e3d-4142-ad45-70c84bfa5949",
      "name": "Anthropic Chat Model1",
      "disabled": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        17520,
        7984
      ],
      "id": "c5baf36f-834e-4fe7-869f-090b46f16c80",
      "name": "Anthropic Chat Model2",
      "disabled": true
    },
    {
      "parameters": {
        "description": "=Call this tool to query data from our knowledgebase using hybrid search (vector, lexical, ilike and fuzzy)\n\nYou can set different weights of this hybrid search depending on the type of query.\n\ndense_weight float DEFAULT 0.5,\nsparse_weight float DEFAULT 0.5,\nilike_weight float DEFAULT 0\nfuzzy_weight float DEFAULT 0\nfuzzy_threshold float DEFAULT 0.8\n\nFor semantic natural lanauge queries you can prioritise dense embeddings, \nFor technical terms and more traditional search you can priorize sparse lexical search\nFor exact matches for codes and IDs you can prioritze ilike wildcard matching\nFor typos that aren't picked up by semantic search, you can prioritize fuzzy matching\n\nIf looking for matches via ilike or fuzzy matches, the query should be extremely focused and short, as otherwise it will likely return zero results. (e.g. exact ID or code)\n\nAs pattern matching and fuzzy matching can add latency, I recommend defaulting this to zero unless you want to actually use it.\n\nTotal of the 4 weights much equal 1\n\nFuzzy Threshold adds significant latency should should be as high as possible - Default to 0.8",
        "workflowId": {
          "__rl": true,
          "value": "suQZAl0QM15VyY3R",
          "mode": "list",
          "cachedResultUrl": "/workflow/suQZAl0QM15VyY3R",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.3 Blueprint"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        16384,
        7952
      ],
      "id": "2d172a06-9ed9-4729-a758-51cbf50303dd",
      "name": "Dynamic Hybrid Search1",
      "disabled": true
    },
    {
      "parameters": {
        "description": "=Call this tool to query data from our knowledgebase using hybrid search (vector, lexical, ilike and fuzzy)\n\nYou can set different weights of this hybrid search depending on the type of query.\n\ndense_weight float DEFAULT 0.5,\nsparse_weight float DEFAULT 0.5,\nilike_weight float DEFAULT 0\nfuzzy_weight float DEFAULT 0\nfuzzy_threshold float DEFAULT 0.8\n\nFor semantic natural lanauge queries you can prioritise dense embeddings, \nFor technical terms and more traditional search you can priorize sparse lexical search\nFor exact matches for codes and IDs you can prioritze ilike wildcard matching\nFor typos that aren't picked up by semantic search, you can prioritize fuzzy matching\n\nIf looking for matches via ilike or fuzzy matches, the query should be extremely focused and short, as otherwise it will likely return zero results. (e.g. exact ID or code)\n\nAs pattern matching and fuzzy matching can add latency, I recommend defaulting this to zero unless you want to actually use it.\n\nTotal of the 4 weights much equal 1\n\nFuzzy Threshold adds significant latency should should be as high as possible - Default to 0.8",
        "workflowId": {
          "__rl": true,
          "value": "BBep2uTA4ZltoqZF",
          "mode": "list",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.2 Active"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        18176,
        7984
      ],
      "id": "752db5c4-05a6-4c63-bfe3-10e7e6765b42",
      "name": "Dynamic Hybrid Search2",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        15280,
        7952
      ],
      "id": "a3a90ed7-0177-4e3a-ae63-7d5ac8ec1944",
      "name": "Fetch Document Hierarchy",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://mgistrmwhxccyuchokbh.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        15456,
        7952
      ],
      "id": "bcb25e6a-e757-41df-86cc-7b00b2fff29f",
      "name": "Context Expansion",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        16720,
        7952
      ],
      "id": "cd1f5079-6f56-4a26-9a00-33aed6a57ec1",
      "name": "Fetch Document Hierarchy1",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://iwcionhpeltdhfrtimtp.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        16896,
        7952
      ],
      "id": "ecf7fa43-0522-4a29-b471-3d28328affe2",
      "name": "Context Expansion1",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        18496,
        7984
      ],
      "id": "34513430-d695-4d96-94d3-822ca49aa260",
      "name": "Fetch Document Hierarchy2",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://iwcionhpeltdhfrtimtp.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        18672,
        7984
      ],
      "id": "91d73df7-abfb-42ef-a36e-85b224b8f0aa",
      "name": "Context Expansion2",
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are an AI assistant responding to a user's query based STRICTLY on the information available in the knowledgebase. You are a factual retrieval system, not a creative assistant.\n\n# Goal\n\nYou are tasked with creating and executing a retrieval strategy to best answer the user's question.\n\nThe output should be a well-researched response based on the output from these tools ONLY, following the Operating Procedures and Response Rules below.\n\nYou must consider both the conversation history and the current query.\n\nYour goal is to provide a fully grounded, accurate answer based on the output from these tools ONLY.\n\n# Standard Operating Procedure\n\n1. Based on your retrieval strategy, pass relevant query(s) to the dynamic hybrid search to narrow the search and retrieve candidate chunks\n2. Based on the most relevant chunk(s); Trigger the Fetch Document Hierarchy Tool to load the source Document's Structure\n3. Based on this document structure (which includes chunk ranges) along with any relevant child_ranges and parent_ranges from the retrieved chunks, trigger the Context Expansion tool to expand your insight into the document.\n\nOnce you've collected enough information, then answer the question, based on the info in context.\n\n# Response Rules\n\n- Ideal target format and length: Multiple Paragraphs\n- Use markdown formatting with appropriate section headings\n- Please respond in the same language as the user's question.\n- If there are images provided from the retrieved information, you should return this in markdown format.\n- Ensure the response maintains continuity with the conversation history.\n\n## Grounding & Citation Rules (CRITICAL)\n\n- Every factual claim MUST be supported by a specific retrieved chunk. Cite inline using [Document Name, p.X] format.\n- Do NOT infer, extrapolate, or combine information in ways not directly supported by the retrieved text.\n- Do NOT add background knowledge, general explanations, or context that is not present in the retrieved documents.\n- If the retrieved information only partially answers the question, explicitly state what you found and what remains unanswered. Say: \"Based on the available documents, I can answer X but not Y.\"\n- If multiple sources provide conflicting information, present both perspectives with their citations rather than choosing one.\n- Do NOT paraphrase loosely. Stay close to the original wording of the source material.\n- If you cannot answer the question using the provided information or if no information is returned from the tools, say: \"I don't have enough information in the knowledge base to answer this question.\"\n\n## References\n\n- List between 1-5 important reference sources at the end under a \"References\" section.\n- Provide Document Names and Page Numbers where these sources appear â€” this is in the chunk metadata.\n- Only list sources you actually cited in your response."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        14912,
        7696
      ],
      "id": "0f67afce-37b6-4d88-b237-78c6eb182a31",
      "name": "Agentic RAG 1",
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are an AI assistant responding to a user's query based on the information provided by multiple knowledgebases - Hybrid Search, Knowledge Graph and Structured datasets.\n\n# Goal\n\nYou are tasked with creating and executing a retrieval strategy to best answer the users question.\n\nThe output should be a well-reserached response to the users query based on the output from these tools and to follow the Operating Procedures and Response Rules as set about below.\n\nYou must consider both the conversation history and the current query.\n\nYour goal is to provide a fully grounded, accurate answer based on the output from these tools ONLY.\n\n# Standard Operating Procedure\n\nBased on your retrieval strategy\n\n## Hybrid Search & Context Expansion\n\n1. Pass relevant query(s) to the dynamic hybrid search to narrow the search and retrieve candidate chunks\n\n2. Based on the most relevant chunk(s); Trigger the Fetch Document Hierarchy Tool to load the source Documents Structure\n\n3. Based on this document structure (which includes chunk ranges) along with any relevant child_ranges and parent_ranges from the retrieved chunks, trigger the Context Expansion tool to expand your insight into the document.\n\n## Tabular Data\n\nIf the question involves tabular dataâ€”such as calculating sums, averages, or finding maximum valuesâ€”the vector store and graph tools may be unreliable. \n\nIn that case, start by reviewing the available datasets, identify the ones most likely to contain the answer, and then construct a SQL query to analyze them.\n\n## Knowledge Graph\n\nIf you are asked questions that you think would be best answered with insights from a knowledge graph then please seach the graph\n\n---Response Rules---\n\n- Ideal target format and length: Multiple Paragraphs\n- Use markdown formatting with appropriate section headings\n- Please respond in the same language as the user's question.\n- If there are images provided from the retrieved information, you should return this in markdown format.\n- Ensure the response maintains continuity with the conversation history.\n- List between 1-5 important reference sources at the end under \"References\" section. (Mark the source as (KB) for Knowledgebase, (GR) for Graph or (DB) for Database). If information is from chunks, then provide Document Names and Page Numbers that these sources appear in the documents - this is in the chunk metadata.\n- Do not make anything up. \n- Do not include information not provided by the Knowledge Bases.\n- If you cannot answer the question using the provided information or if no information is returned from the tools, say \"Sorry I don't know\"."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        16096,
        7696
      ],
      "id": "37f213e5-dc62-4d6d-8ac3-49785681d5c0",
      "name": "Agentic RAG 2",
      "retryOnFail": true,
      "maxTries": 5,
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are an AI assistant responding to a user's query based on the information provided by multiple knowledgebases - Hybrid Search, Knowledge Graph and Structured datasets.\n\n# Goal\n\nYou are tasked with creating and executing a retrieval strategy to best answer the users question.\n\nThe output should be a well-reserached response to the users query based on the output from these tools and to follow the Operating Procedures and Response Rules as set about below.\n\nYou must consider both the conversation history and the current query.\n\nYour goal is to provide a fully grounded, accurate answer based on the output from these tools ONLY.\n\n# Standard Operating Procedure\n\nBased on your retrieval strategy\n\n## Hybrid Search & Context Expansion\n\n1. Pass relevant query(s) to the dynamic hybrid search to narrow the search and retrieve candidate chunks\n\n2. Based on the most relevant chunk(s); Trigger the Fetch Document Hierarchy Tool to load the source Documents Structure\n\n3. Based on this document structure (which includes chunk ranges) along with any relevant child_ranges and parent_ranges from the retrieved chunks, trigger the Context Expansion tool to expand your insight into the document.\n\n## Tabular Data\n\nIf the question involves tabular dataâ€”such as calculating sums, averages, or finding maximum valuesâ€”the vector store and graph tools may be unreliable. \n\nIn that case, start by reviewing the available datasets, identify the ones most likely to contain the answer, and then construct a SQL query to analyze them.\n\n## Knowledge Graph\n\nIf you are asked questions that you think would be best answered with insights from a knowledge graph then please seach the graph\n\n---Response Rules---\n\n- Ideal target format and length: Multiple Paragraphs\n- Use markdown formatting with appropriate section headings\n- Please respond in the same language as the user's question.\n- If there are images provided from the retrieved information, you should return this in markdown format.\n- Ensure the response maintains continuity with the conversation history.\n- List between 1-5 important reference sources at the end under \"References\" section. (Mark the source as (KB) for Knowledgebase, (GR) for Graph or (DB) for Database). If information is from chunks, then provide Document Names and Page Numbers that these sources appear in the documents - this is in the chunk metadata.\n- Do not make anything up. \n- Do not include information not provided by the Knowledge Bases.\n- If you cannot answer the question using the provided information or if no information is returned from the tools, say \"Sorry I don't know\".\n\n{{\n(() => {\n  const raw = $json.data;\n  if (raw == null) return '';\n\n  const toText = v => (typeof v === 'string' ? v : JSON.stringify(v));\n  const rawText = toText(raw);\n  const cleaned = rawText.replace(/[\\u0000-\\u001F\\u007F]/g, '').trim();\n  if (!cleaned || cleaned === '{}' || cleaned === '[]') return '';\n\n  // Parse only if the cleaned text looks like JSON\n  let obj = raw;\n  if (typeof raw === 'string') {\n    const first = cleaned[0];\n    if (first === '{' || first === '[') {\n      try { obj = JSON.parse(cleaned); } catch { return ''; }\n    } else {\n      return '';\n    }\n  }\n\n  // Support either { edges: [...] } or a bare array of edges\n  const edges = Array.isArray(obj?.edges) ? obj.edges : (Array.isArray(obj) ? obj : []);\n  if (!edges.length) return '';\n\n  const facts = [...new Set(\n    edges\n      .map(e => (e && typeof e.fact === 'string') ? e.fact.replace(/\\s+/g, ' ').trim() : '')\n      .filter(Boolean)\n  )];\n\n  return facts.length\n    ? \"---User Information---\\nThis is information about the user:\\n\" + facts.map(f => \"- \" + f).join(\"\\n\")\n    : '';\n})()\n}}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        17776,
        7728
      ],
      "id": "e89c8600-aad3-4eb4-8207-ebbdcf52d656",
      "name": "Agentic RAG 3",
      "retryOnFail": true,
      "maxTries": 5,
      "disabled": true
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "query"
            },
            {
              "name": "type"
            },
            {
              "name": "session_id"
            },
            {
              "name": "dense_weight",
              "type": "number"
            },
            {
              "name": "sparse_weight",
              "type": "number"
            },
            {
              "name": "ilike_weight",
              "type": "number"
            },
            {
              "name": "fuzzy_weight",
              "type": "number"
            },
            {
              "name": "fuzzy_threshold",
              "type": "number"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        14704,
        8416
      ],
      "id": "e3de5483-93ec-461d-9484-4c2210fef6d1",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "={{ $('When Executed by Another Workflow').item.json.query }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        16624,
        8416
      ],
      "id": "528a2c95-2947-450b-a475-8c79cbe05c77",
      "name": "Generate Embedding From Query",
      "credentials": {
        "openAiApi": {
          "id": "r6dwaEmQxKEvrskM",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cohere.com/v2/rerank",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"rerank-v3.5\",\n  \"query\": \"{{ $('When Executed by Another Workflow').first().json.query }}\",\n  \"top_n\": 10,\n  \"documents\": {{ JSON.stringify($json.documents) }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        17680,
        8416
      ],
      "id": "82eeee1f-5f41-4ef7-ac47-80e56e62a2b3",
      "name": "Rerank with Cohere 3.5",
      "credentials": {
        "httpHeaderAuth": {
          "id": "lSFkzmpI1ZAMZqHr",
          "name": "Header Auth account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// --- This Code Node extracts 'content' from multiple input items ---\n\n// Step 1: Use .map() to iterate over ALL incoming items ($input.all()).\n// For each item, access its 'json' property, and then the 'content' field within that.\nconst contentArray = $input.all().map(item => {\n  // Basic safety check: ensure item.json and item.json.content exist.\n  // Return null or an empty string if not found, otherwise return the content.\n  // Adjust the fallback value (null) if needed.\n  return item.json?.content ?? null;\n});\n\n// Step 2: Filter out any potential null values if an item was missing content (optional)\n// If you are certain all items will have content, you can skip this filter.\nconst validContentArray = contentArray.filter(content => content !== null);\n\n// Step 3: Return the result as a *single* new n8n item.\n// This item contains your final array of strings under the 'documents' key.\nreturn [{\n  json: {\n    // Use validContentArray if you filtered, otherwise use contentArray\n    documents: validContentArray\n    // documents: contentArray // <-- Use this if you didn't filter\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17440,
        8416
      ],
      "id": "fee7fab9-6c2a-4555-a319-dfcc2a5b1945",
      "name": "Create Array",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// --- Code Node to Reorder Items Based on Rerank Results (WITH METADATA) ---\n\n// --- Step 1: Get Data from Input Nodes ---\n\n// Get the ORIGINAL full items (with content + metadata) from the node that outputs them\n// Replace 'Vector Store' with the actual name of your node that outputs the chunks\nconst originalFullItems = $('Trigger Dynamic Hybrid Search').all();\n\n// Get the rerank results array from the Cohere Rerank node\nconst rerankOrderInfo = $input.first().json.results;\n\n// --- Step 2: Validate Inputs ---\nif (!Array.isArray(originalFullItems) || originalFullItems.length === 0) {\n  throw new Error(\"Could not retrieve original items with metadata. Check the source node name.\");\n}\n\nif (!Array.isArray(rerankOrderInfo) || rerankOrderInfo.length === 0) {\n  if (originalFullItems.length !== 0) {\n    throw new Error(\"Could not get valid rerank results from the input node.\");\n  }\n}\n\n// --- Step 3: Reorder the FULL Items (content + metadata) ---\nlet sortedItems = [];\n\nif (rerankOrderInfo && rerankOrderInfo.length > 0 && originalFullItems && originalFullItems.length > 0) {\n  sortedItems = rerankOrderInfo.map(rankInfo => {\n    const originalIndex = rankInfo.index;\n    \n    // Check if the index is valid\n    if (originalIndex !== undefined && originalIndex !== null && \n        originalIndex >= 0 && originalIndex < originalFullItems.length) {\n      \n      // Get the full original item (with all metadata)\n      const originalItem = originalFullItems[originalIndex].json;\n      \n      // Optionally add the rerank score to the item\n      return {\n        ...originalItem,\n        rerank_score: rankInfo.relevance_score // Cohere's relevance score\n      };\n    } else {\n      console.error(`Error: Rerank index ${originalIndex} is invalid. Skipping.`);\n      return null;\n    }\n  }).filter(item => item !== null);\n} else {\n  sortedItems = [];\n  console.log(\"Input data is empty, resulting in empty sorted output.\");\n}\n\n// --- Step 4: Return the Sorted Items ---\n// Option A: Return as multiple n8n items (one per document)\nreturn sortedItems.map(item => ({ json: item }));\n\n// Option B: Return as single item with array (uncomment if preferred)\n// return [{ json: { sortedDocuments: sortedItems } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17904,
        8416
      ],
      "id": "bac969d0-1ada-4b72-886b-ea33b4c5f2e3",
      "name": "Return Reordered Items1",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## Hybrid Search",
        "height": 552,
        "width": 536,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        16560,
        8272
      ],
      "id": "1413c48a-e23b-4566-9b2a-b155e565bd50",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "content": "## Reranking",
        "height": 552,
        "width": 1044,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17120,
        8272
      ],
      "id": "0a079560-dee2-4bf4-bee3-f2bcb5ebcbf3",
      "name": "Sticky Note12",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "71326cd6-1316-4b5e-bf34-0d0b3c086005",
              "leftValue": "={{ $('Trigger Dynamic Hybrid Search').item.json.keys().length}}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        17168,
        8416
      ],
      "id": "385fe667-26ec-4f06-9aab-5bbe17ab40c2",
      "name": "If3",
      "alwaysOutputData": false,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "return [{\n  message: \"no documents found\" \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17440,
        8640
      ],
      "id": "a376ed37-b6b1-4ed6-89ea-b4e8d2d533e4",
      "name": "Code",
      "disabled": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "hybrid",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "322d7a20-e584-4a2c-ad39-987298dabdf1"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4c020ce0-c212-4e62-9c42-863f0358d065",
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "graph",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        14896,
        8416
      ],
      "id": "0f563eaa-8067-4cb2-81e5-778657891da8",
      "name": "Switch2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://YOUR_LIGHTRAG_URL/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query\": \"{{ $('When Executed by Another Workflow').item.json.query }}\",\n  \"mode\": \"hybrid\",\n  \"only_need_context\": true,\n  \"only_need_prompt\": false,\n  \"response_type\": \"multiple paragraphs\",\n  \"top_k\": 20,\n  \"chunk_top_k\": 1,\n  \"max_entity_tokens\": 10000,\n  \"max_relation_tokens\": 10000,\n  \"max_total_tokens\": 32000,\n  \"enable_rerank\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        15600,
        9024
      ],
      "id": "dc77dd73-db37-4d20-8559-4fa0ce72951c",
      "name": "Query Graph",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and extract everything before \"-----Document Chunks(DC)-----\"\nfor (const item of $input.all()) {\n\n  const intro = \"The following entities and relationships were retrived.\\n\\n\"\n  const outro = \"-----How to use this data-----\\n\\nWhen considering relationships with timestamps:\\n\\nEach relationship has a \\\"created_at\\\" timestamp indicating when we acquired this knowledge. When encountering conflicting relationships, consider both the semantic content and the timestamp. Don't automatically prefer the most recently created relationships - use judgment based on the context. For time-specific queries, prioritize temporal information in the content before considering creation timestamps\"\n  \n  // Get the input string - adjust this based on where your string is located\n  const inputString = item.json.response; // Change 'response' to your actual field name\n  \n  // Define the substring to search for\n  const separator = \"-----Document Chunks(DC)-----\";\n  \n  // Find the position of the separator\n  const separatorIndex = inputString.indexOf(separator);\n  \n  let extractedContent = \"\";\n  \n  if (separatorIndex !== -1) {\n    // Extract everything before the separator\n    extractedContent = inputString.substring(0, separatorIndex);\n  } else {\n    // If separator not found, return the entire string\n    extractedContent = inputString;\n  }\n  \n  // Add the extracted content to the item\n  item.json.response = intro + extractedContent + outro;\n\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15840,
        9024
      ],
      "id": "2e930dfc-f492-4a19-9b08-67e1a72044c2",
      "name": "Tidy up response",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## Graph Search",
        "height": 348,
        "width": 800,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        15456,
        8880
      ],
      "id": "276eb8c1-58a6-4d49-83c4-42c66059605c",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "content": "## Advanced Metadata Filtering",
        "height": 552,
        "width": 1104,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        15472,
        8272
      ],
      "id": "bdc004d6-00af-4be9-97ab-e161867aa252",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "options": {
          "groupMessages": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.memoryManager",
      "typeVersion": 1.1,
      "position": [
        15152,
        8384
      ],
      "id": "62726327-340d-4d02-b9b1-41d2b79ab54f",
      "name": "Chat Memory Manager",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "chatgpt-4o-latest",
          "mode": "list",
          "cachedResultName": "chatgpt-4o-latest"
        },
        "options": {
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        16160,
        8624
      ],
      "id": "d5eff8ca-287e-47fd-938a-62519a500d9f",
      "name": "OpenAI Chat Model4",
      "credentials": {
        "openAiApi": {
          "id": "r6dwaEmQxKEvrskM",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# User Query\n{{ $('When Executed by Another Workflow').first().json.query }}\n\n# Conversation History (if any)\n{{ JSON.stringify($('Chat Memory Manager').first().json) }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=# Task\n\nYour task is to consider the following user query and then consider the following metadata keys with example values that we have that we can limit our result set from.\n\n# Metadata Filters and Possible Values\n\n{{ $json.filterPromptInstructions }}\n\n# Metadata Operators\n\nThe following operators are allowed:\n\n>\n<\n=\n!=\n>=\n<=\nIN\nNOT IN\n\nIF IN or NOT IN are provided, then an array of values must be provided.\n\nNow output a filter array with relevant filters with the following example format. The below filter_categories are just for exampe purposes. Use the \"Metadata Filters and Possible Values\" list above for the list of allowed filters.\n\n[\n    \"filter\": {\n      \"$and\": [\n        {\n          \"category\": {\n            \"operator\": \"IN\",\n            \"value\": [\n              \"F1\",\n              \"Rally\"\n            ]\n          }\n        },\n        {\n          \"year\": {\n            \"operator\": \">\",\n            \"value\": 2024\n          }\n        }\n      ]\n    }\n]\n\nIf the query does not have relevant metadatafilters, then do not output any ... for example\n\n{\n  \"filter\": {}\n}\n\nIf there is only 1 relevant metadafilter, then just output that ... for example\n\n[\n    \"filter\": {\n      \"$and\": [\n        {\n          \"motorsport_category\": {\n            \"operator\": \"IN\",\n            \"value\": [\n              \"F1\",\n              \"Rally\"\n            ]\n          }\n        }\n      ]\n    }\n]\n\nOnly output in JSON\n\nNote: Today's date is {{ $now }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        16176,
        8400
      ],
      "id": "14e810c2-7125-42c7-8ad5-378ad03fbfad",
      "name": "Prep Metadata1",
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"FlexibleFilterObject\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"filter\": {\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\"$and\"],\n          \"properties\": {\n            \"$and\": {\n              \"type\": \"array\",\n              \"items\": { \"$ref\": \"#/definitions/condition\" }\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"required\": [\"$or\"],\n          \"properties\": {\n            \"$or\": {\n              \"type\": \"array\",\n              \"items\": { \"$ref\": \"#/definitions/condition\" }\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"properties\": {},\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"required\": [\"filter\"],\n  \"definitions\": {\n    \"condition\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\",\n          \"required\": [\"field\", \"operator\", \"value\"],\n          \"properties\": {\n            \"field\": { \"type\": \"string\" },\n            \"operator\": {\n              \"type\": \"string\",\n              \"enum\": [\"=\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"IN\", \"NOT IN\"]\n            },\n            \"value\": {\n              \"oneOf\": [\n                { \"type\": \"string\" },\n                { \"type\": \"number\" },\n                {\n                  \"type\": \"array\",\n                  \"items\": { \"type\": [\"string\", \"number\"] }\n                }\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"type\": \"object\",\n          \"minProperties\": 1,\n          \"maxProperties\": 1,\n          \"patternProperties\": {\n            \"^.+$\": {\n              \"type\": \"object\",\n              \"required\": [\"operator\", \"value\"],\n              \"properties\": {\n                \"operator\": {\n                  \"type\": \"string\",\n                  \"enum\": [\"=\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"IN\", \"NOT IN\"]\n                },\n                \"value\": {\n                  \"oneOf\": [\n                    { \"type\": \"string\" },\n                    { \"type\": \"number\" },\n                    {\n                      \"type\": \"array\",\n                      \"items\": { \"type\": [\"string\", \"number\"] }\n                    }\n                  ]\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        16336,
        8624
      ],
      "id": "676846a2-4f67-4851-a016-6ee3caed4a56",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "content": "# Retrieval Sub-Workflow",
        "height": 552,
        "width": 840,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        14592,
        8272
      ],
      "id": "b602beda-2050-4743-ba88-b7c2d49cddcf",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "metadata_fields"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        15520,
        8416
      ],
      "id": "ba3e0221-d13f-412b-8d75-2c0063475ccc",
      "name": "Fetch Metadata Fields1",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get input items\nconst items = $input.all();\n\n// Initialize output string\nlet output = '';\n\n// Loop through each input item\nfor (const item of items) {\n  const data = item.json;\n\n  const key = data.metadata_name;\n  const values = data.allowed_values;\n\n  output += `## ${key}\\n`;\n  output += `The filter key ${key} can have the following possible values\\n\\n`;\n  output += `${values.trim()}\\n\\n`;\n}\n\n// Take the first item and modify it with aggregated data\nconst firstItem = items[0];\nfirstItem.json.filterPromptInstructions = output.trim();\n\n// Return only the first item (now containing aggregated data)\nreturn [firstItem];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15952,
        8416
      ],
      "id": "1dd07615-b134-4b43-b0fc-b3cc95e7aa79",
      "name": "Prep1"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('When Executed by Another Workflow').item.json.session_id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        15248,
        8576
      ],
      "id": "cf905bbb-aace-48a9-9200-437fbe532e8b",
      "name": "Supabase Short-Term Memory1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "## TODO\n### Add LightRAG Server URL",
        "height": 252,
        "width": 280
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        15520,
        8928
      ],
      "id": "76c8d018-bcac-4196-acfe-4a260620396d",
      "name": "Sticky Note19",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a4697977-31b6-4740-ae7c-0e3a35ecfdf0",
              "leftValue": "={{ $json }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        15728,
        8528
      ],
      "id": "29e949e5-4eea-4e92-8a9d-727f39181b4d",
      "name": "If"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://mgistrmwhxccyuchokbh.supabase.co/functions/v1/dynamic-hybrid-search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n        \"query_text\": \"{{ $('When Executed by Another Workflow').item.json.query }}\",\n        \"query_embedding\": [{{ $json.data[0].embedding }}],\n        \"match_count\": 30,\n        \"filter\": {{ $('Prep Metadata1').isExecuted ? JSON.stringify($('Prep Metadata1').item.json.output.filter) : \"[]\" }},\n\"dense_weight\": {{ $('When Executed by Another Workflow').item.json.dense_weight }},\n\"sparse_weight\": {{ $('When Executed by Another Workflow').item.json.sparse_weight }},\n\"ilike_weight\": {{ $('When Executed by Another Workflow').item.json.ilike_weight }},\n\"fuzzy_weight\": {{ $('When Executed by Another Workflow').item.json.fuzzy_weight }},\n\"fuzzy_threshold\": {{ $('When Executed by Another Workflow').item.json.fuzzy_threshold }}\n      }",
        "options": {
          "redirect": {
            "redirect": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        16864,
        8448
      ],
      "id": "291dfd44-7bc3-48bd-88b0-5dece189576f",
      "name": "Trigger Dynamic Hybrid Search",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "content": "## TODO\n### Add Edge Function URL\nYou can also change number of results returned",
        "height": 332,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        16800,
        8304
      ],
      "id": "a8b38973-571c-4440-bdba-9c6faa6d7a9e",
      "name": "Sticky Note22"
    },
    {
      "parameters": {
        "content": "## TODO (Optional)\nYou can change the number of results returned",
        "height": 300,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17616,
        8304
      ],
      "id": "3474cd3a-d2f2-4296-90b2-0285a20c6340",
      "name": "Sticky Note23",
      "disabled": true
    },
    {
      "parameters": {
        "content": "",
        "height": 648,
        "width": 840,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13696,
        8272
      ],
      "id": "19310bde-bc89-4d06-8115-6d72bfca4fe0",
      "name": "Sticky Note24"
    },
    {
      "parameters": {
        "content": "## v2.3.3\nThis it the retrieval sub-workflow for both our SOTA RAG System and RAG At Scale System\n\nSOTA RAG Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/state-of-the-art-n8n-rag-agent\n\nRAG at Scale Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/rag-at-scale-system",
        "height": 244,
        "width": 580,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13856,
        8640
      ],
      "id": "a6f7efc1-a21e-44aa-aede-896a453a34f2",
      "name": "Sticky Note28"
    },
    {
      "parameters": {
        "content": "## TODO\n### Connect the Chat Trigger to your Agent of Choice",
        "height": 256,
        "width": 576
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13856,
        8352
      ],
      "id": "853e794a-438e-4695-848c-8b423b00542c",
      "name": "Sticky Note30"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5.2-2025-12-11",
          "mode": "list",
          "cachedResultName": "gpt-5.2-2025-12-11"
        },
        "builtInTools": {},
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        14784,
        7968
      ],
      "id": "83c65cde-0cf6-4abd-aa26-b4b7f1823564",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "r6dwaEmQxKEvrskM",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "description": "=Call this tool to query data from our knowledgebase using hybrid search (vector, lexical, ilike and fuzzy)\n\nYou can set different weights of this hybrid search depending on the type of query.\n\ndense_weight float DEFAULT 0.5,\nsparse_weight float DEFAULT 0.5,\nilike_weight float DEFAULT 0\nfuzzy_weight float DEFAULT 0\nfuzzy_threshold float DEFAULT 0.8\n\nFor semantic natural lanauge queries you can prioritise dense embeddings, \nFor technical terms and more traditional search you can priorize sparse lexical search\nFor exact matches for codes and IDs you can prioritze ilike wildcard matching\nFor typos that aren't picked up by semantic search, you can prioritize fuzzy matching\n\nIf looking for matches via ilike or fuzzy matches, the query should be extremely focused and short, as otherwise it will likely return zero results. (e.g. exact ID or code)\n\nAs pattern matching and fuzzy matching can add latency, I recommend defaulting this to zero unless you want to actually use it.\n\nTotal of the 4 weights much equal 1\n\nFuzzy Threshold adds significant latency should should be as high as possible - Default to 0.8",
        "workflowId": {
          "__rl": true,
          "value": "R_I-MybamT9nBjj0P-Gg3",
          "mode": "list",
          "cachedResultUrl": "/workflow/R_I-MybamT9nBjj0P-Gg3",
          "cachedResultName": "Retrieval Sub-Workflow"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        15136,
        7968
      ],
      "id": "532aa8d8-f0fc-4274-9080-118c4dbd56f2",
      "name": "Dynamic Hybrid Search3"
    }
  ],
  "pinData": {},
  "connections": {
    "Supabase Short-Term Memory": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory2": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Get Long Term Memories": {
      "main": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "user_id": {
      "main": [
        [
          {
            "node": "Get Long Term Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Tabular Rows1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get datasets from record_manager1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query Knowledge Graph2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory3": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Query Tabular Rows2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get datasets from record_manager2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query Knowledge Graph1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Agentic RAG 3": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Execute workflow - Save Zep long term memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding From Query": {
      "main": [
        [
          {
            "node": "Trigger Dynamic Hybrid Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rerank with Cohere 3.5": {
      "main": [
        [
          {
            "node": "Return Reordered Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Array": {
      "main": [
        [
          {
            "node": "Rerank with Cohere 3.5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Create Array",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch2": {
      "main": [
        [
          {
            "node": "Chat Memory Manager",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Query Graph",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Graph": {
      "main": [
        [
          {
            "node": "Tidy up response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Memory Manager": {
      "main": [
        [
          {
            "node": "Fetch Metadata Fields1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model4": {
      "ai_languageModel": [
        [
          {
            "node": "Prep Metadata1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Prep Metadata1": {
      "main": [
        [
          {
            "node": "Generate Embedding From Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Prep Metadata1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Metadata Fields1": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep1": {
      "main": [
        [
          {
            "node": "Prep Metadata1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory1": {
      "ai_memory": [
        [
          {
            "node": "Chat Memory Manager",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Prep1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Embedding From Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Dynamic Hybrid Search": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search3": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false,
    "timeSavedMode": "fixed",
    "callerPolicy": "any"
  },
  "versionId": "a5eae888-34b3-4bc2-93e1-074bc12b2587",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "eaa3d31df30f69d853bf1887372824077726204755d7d83df055afd95f72246a"
  },
  "id": "R_I-MybamT9nBjj0P-Gg3",
  "tags": [
    {
      "updatedAt": "2026-02-15T11:24:51.266Z",
      "createdAt": "2026-02-15T11:24:51.266Z",
      "id": "OEoaSAg7UTdJYuMl",
      "name": "BVIJ"
    },
    {
      "updatedAt": "2026-02-15T13:10:47.882Z",
      "createdAt": "2026-02-15T13:10:47.882Z",
      "id": "Z2OUf4P51HExgS2t",
      "name": "DEV"
    }
  ]
}